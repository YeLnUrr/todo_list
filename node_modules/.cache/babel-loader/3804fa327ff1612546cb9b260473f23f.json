{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { toChecksumAddress } from 'web3-utils';\nimport { isAddress, utils } from 'web3-validator';\nimport { alloc, WORD_SIZE } from '../utils.js';\nconst ADDRESS_BYTES_COUNT = 20;\nconst ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;\nexport function encodeAddress(param, input) {\n  if (typeof input !== 'string') {\n    throw new AbiError('address type expects string as input type', {\n      value: input,\n      name: param.name,\n      type: param.type\n    });\n  }\n\n  let address = input.toLowerCase();\n\n  if (!address.startsWith('0x')) {\n    address = `0x${address}`;\n  }\n\n  if (!isAddress(address)) {\n    throw new AbiError('provided input is not valid address', {\n      value: input,\n      name: param.name,\n      type: param.type\n    });\n  } // for better performance, we could convert hex to destination bytes directly (encoded var)\n\n\n  const addressBytes = utils.hexToUint8Array(address); // expand address to WORD_SIZE\n\n  const encoded = alloc(WORD_SIZE);\n  encoded.set(addressBytes, ADDRESS_OFFSET);\n  return {\n    dynamic: false,\n    encoded\n  };\n}\nexport function decodeAddress(_param, bytes) {\n  const addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);\n\n  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {\n    throw new AbiError('Invalid decoding input, not enough bytes to decode address', {\n      bytes\n    });\n  }\n\n  const result = utils.uint8ArrayToHexString(addressBytes); // should we check is decoded value is valid address?\n  // if(!isAddress(result)) {\n  //     throw new AbiError(\"encoded data is not valid address\", {\n  //         address: result,\n  //     });\n  // }\n\n  return {\n    result: toChecksumAddress(result),\n    encoded: bytes.subarray(WORD_SIZE),\n    consumed: WORD_SIZE\n  };\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,SAASA,QAAT,QAAyB,aAAzB;AAEA,SAASC,iBAAT,QAAkC,YAAlC;AACA,SAASC,SAAT,EAAoBC,KAApB,QAAiC,gBAAjC;AAEA,SAASC,KAAT,EAAgBC,SAAhB,QAAiC,aAAjC;AAEA,MAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAMC,cAAc,GAAGF,SAAS,GAAGC,mBAAnC;AAEA,OAAM,SAAUE,aAAV,CAAwBC,KAAxB,EAA6CC,KAA7C,EAA2D;EAChE,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC9B,MAAM,IAAIV,QAAJ,CAAa,2CAAb,EAA0D;MAC/DW,KAAK,EAAED,KADwD;MAE/DE,IAAI,EAAEH,KAAK,CAACG,IAFmD;MAG/DC,IAAI,EAAEJ,KAAK,CAACI;IAHmD,CAA1D,CAAN;EAKA;;EACD,IAAIC,OAAO,GAAGJ,KAAK,CAACK,WAAN,EAAd;;EACA,IAAI,CAACD,OAAO,CAACE,UAAR,CAAmB,IAAnB,CAAL,EAA+B;IAC9BF,OAAO,GAAG,KAAKA,OAAO,EAAtB;EACA;;EACD,IAAI,CAACZ,SAAS,CAACY,OAAD,CAAd,EAAyB;IACxB,MAAM,IAAId,QAAJ,CAAa,qCAAb,EAAoD;MACzDW,KAAK,EAAED,KADkD;MAEzDE,IAAI,EAAEH,KAAK,CAACG,IAF6C;MAGzDC,IAAI,EAAEJ,KAAK,CAACI;IAH6C,CAApD,CAAN;EAKA,CAlB+D,CAmBhE;;;EACA,MAAMI,YAAY,GAAGd,KAAK,CAACe,eAAN,CAAsBJ,OAAtB,CAArB,CApBgE,CAqBhE;;EACA,MAAMK,OAAO,GAAGf,KAAK,CAACC,SAAD,CAArB;EACAc,OAAO,CAACC,GAAR,CAAYH,YAAZ,EAA0BV,cAA1B;EACA,OAAO;IACNc,OAAO,EAAE,KADH;IAENF;EAFM,CAAP;AAIA;AAED,OAAM,SAAUG,aAAV,CAAwBC,MAAxB,EAA8CC,KAA9C,EAA+D;EACpE,MAAMP,YAAY,GAAGO,KAAK,CAACC,QAAN,CAAelB,cAAf,EAA+BF,SAA/B,CAArB;;EACA,IAAIY,YAAY,CAACS,MAAb,KAAwBpB,mBAA5B,EAAiD;IAChD,MAAM,IAAIN,QAAJ,CAAa,4DAAb,EAA2E;MAAEwB;IAAF,CAA3E,CAAN;EACA;;EACD,MAAMG,MAAM,GAAGxB,KAAK,CAACyB,qBAAN,CAA4BX,YAA5B,CAAf,CALoE,CAOpE;EACA;EACA;EACA;EACA;EACA;;EACA,OAAO;IACNU,MAAM,EAAE1B,iBAAiB,CAAC0B,MAAD,CADnB;IAENR,OAAO,EAAEK,KAAK,CAACC,QAAN,CAAepB,SAAf,CAFH;IAGNwB,QAAQ,EAAExB;EAHJ,CAAP;AAKA","names":["AbiError","toChecksumAddress","isAddress","utils","alloc","WORD_SIZE","ADDRESS_BYTES_COUNT","ADDRESS_OFFSET","encodeAddress","param","input","value","name","type","address","toLowerCase","startsWith","addressBytes","hexToUint8Array","encoded","set","dynamic","decodeAddress","_param","bytes","subarray","length","result","uint8ArrayToHexString","consumed"],"sources":["C:\\Users\\Asus\\Desktop\\todolist-blockchain\\node_modules\\web3-eth-abi\\src\\coders\\base\\address.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { toChecksumAddress } from 'web3-utils';\nimport { isAddress, utils } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\n\nconst ADDRESS_BYTES_COUNT = 20;\nconst ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;\n\nexport function encodeAddress(param: AbiParameter, input: unknown): EncoderResult {\n\tif (typeof input !== 'string') {\n\t\tthrow new AbiError('address type expects string as input type', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\tlet address = input.toLowerCase();\n\tif (!address.startsWith('0x')) {\n\t\taddress = `0x${address}`;\n\t}\n\tif (!isAddress(address)) {\n\t\tthrow new AbiError('provided input is not valid address', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\t// for better performance, we could convert hex to destination bytes directly (encoded var)\n\tconst addressBytes = utils.hexToUint8Array(address);\n\t// expand address to WORD_SIZE\n\tconst encoded = alloc(WORD_SIZE);\n\tencoded.set(addressBytes, ADDRESS_OFFSET);\n\treturn {\n\t\tdynamic: false,\n\t\tencoded,\n\t};\n}\n\nexport function decodeAddress(_param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);\n\tif (addressBytes.length !== ADDRESS_BYTES_COUNT) {\n\t\tthrow new AbiError('Invalid decoding input, not enough bytes to decode address', { bytes });\n\t}\n\tconst result = utils.uint8ArrayToHexString(addressBytes);\n\n\t// should we check is decoded value is valid address?\n\t// if(!isAddress(result)) {\n\t//     throw new AbiError(\"encoded data is not valid address\", {\n\t//         address: result,\n\t//     });\n\t// }\n\treturn {\n\t\tresult: toChecksumAddress(result),\n\t\tencoded: bytes.subarray(WORD_SIZE),\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}