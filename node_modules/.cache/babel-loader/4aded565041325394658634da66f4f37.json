{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { bytesToHex, bytesToUint8Array } from 'web3-utils';\nimport { isBytes } from 'web3-validator';\nimport { alloc, WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\nconst MAX_STATIC_BYTES_COUNT = 32;\nexport function encodeBytes(param, input) {\n  // hack for odd length hex strings\n  if (typeof input === 'string' && input.length % 2 !== 0) {\n    // eslint-disable-next-line no-param-reassign\n    input += '0';\n  }\n\n  if (!isBytes(input)) {\n    throw new AbiError('provided input is not valid bytes value', {\n      type: param.type,\n      value: input,\n      name: param.name\n    });\n  }\n\n  const bytes = bytesToUint8Array(input);\n  const [, size] = param.type.split('bytes'); // fixed size\n\n  if (size) {\n    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n      throw new AbiError('invalid bytes type. Static byte type can have between 1 and 32 bytes', {\n        type: param.type\n      });\n    }\n\n    if (Number(size) < bytes.length) {\n      throw new AbiError('provided input size is different than type size', {\n        type: param.type,\n        value: input,\n        name: param.name\n      });\n    }\n\n    const encoded = alloc(WORD_SIZE);\n    encoded.set(bytes);\n    return {\n      dynamic: false,\n      encoded\n    };\n  }\n\n  const partsLength = Math.ceil(bytes.length / WORD_SIZE); // one word for length of data + WORD for each part of actual data\n\n  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);\n  encoded.set(encodeNumber({\n    type: 'uint32',\n    name: ''\n  }, bytes.length).encoded);\n  encoded.set(bytes, WORD_SIZE);\n  return {\n    dynamic: true,\n    encoded\n  };\n}\nexport function decodeBytes(param, bytes) {\n  const [, sizeString] = param.type.split('bytes');\n  let size = Number(sizeString);\n  let remainingBytes = bytes;\n  let partsCount = 1;\n  let consumed = 0;\n\n  if (!size) {\n    // dynamic bytes\n    const result = decodeNumber({\n      type: 'uint32',\n      name: ''\n    }, remainingBytes);\n    size = Number(result.result);\n    consumed += result.consumed;\n    remainingBytes = result.encoded;\n    partsCount = Math.ceil(size / WORD_SIZE);\n  }\n\n  if (size > bytes.length) {\n    throw new AbiError('there is not enough data to decode', {\n      type: param.type,\n      encoded: bytes,\n      size\n    });\n  }\n\n  return {\n    result: bytesToHex(remainingBytes.subarray(0, size)),\n    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),\n    consumed: consumed + partsCount * WORD_SIZE\n  };\n}","map":{"version":3,"mappings":"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","names":["AbiError","bytesToHex","bytesToUint8Array","isBytes","alloc","WORD_SIZE","decodeNumber","encodeNumber","MAX_STATIC_BYTES_COUNT","encodeBytes","param","input","length","type","value","name","bytes","size","split","Number","encoded","set","dynamic","partsLength","Math","ceil","decodeBytes","sizeString","remainingBytes","partsCount","consumed","result","subarray"],"sources":["C:\\Users\\Asus\\Desktop\\todolist-blockchain\\node_modules\\web3-eth-abi\\src\\coders\\base\\bytes.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter, Bytes } from 'web3-types';\nimport { bytesToHex, bytesToUint8Array } from 'web3-utils';\nimport { isBytes, ValidInputTypes } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\n\nconst MAX_STATIC_BYTES_COUNT = 32;\n\nexport function encodeBytes(param: AbiParameter, input: unknown): EncoderResult {\n\t// hack for odd length hex strings\n\tif (typeof input === 'string' && input.length % 2 !== 0) {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tinput += '0';\n\t}\n\tif (!isBytes(input as ValidInputTypes)) {\n\t\tthrow new AbiError('provided input is not valid bytes value', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t});\n\t}\n\tconst bytes = bytesToUint8Array(input as Bytes);\n\tconst [, size] = param.type.split('bytes');\n\t// fixed size\n\tif (size) {\n\t\tif (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n\t\t\tthrow new AbiError(\n\t\t\t\t'invalid bytes type. Static byte type can have between 1 and 32 bytes',\n\t\t\t\t{\n\t\t\t\t\ttype: param.type,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tif (Number(size) < bytes.length) {\n\t\t\tthrow new AbiError('provided input size is different than type size', {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: input,\n\t\t\t\tname: param.name,\n\t\t\t});\n\t\t}\n\t\tconst encoded = alloc(WORD_SIZE);\n\t\tencoded.set(bytes);\n\t\treturn {\n\t\t\tdynamic: false,\n\t\t\tencoded,\n\t\t};\n\t}\n\n\tconst partsLength = Math.ceil(bytes.length / WORD_SIZE);\n\t// one word for length of data + WORD for each part of actual data\n\tconst encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);\n\n\tencoded.set(encodeNumber({ type: 'uint32', name: '' }, bytes.length).encoded);\n\tencoded.set(bytes, WORD_SIZE);\n\treturn {\n\t\tdynamic: true,\n\t\tencoded,\n\t};\n}\n\nexport function decodeBytes(param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst [, sizeString] = param.type.split('bytes');\n\tlet size = Number(sizeString);\n\tlet remainingBytes = bytes;\n\tlet partsCount = 1;\n\tlet consumed = 0;\n\tif (!size) {\n\t\t// dynamic bytes\n\t\tconst result = decodeNumber({ type: 'uint32', name: '' }, remainingBytes);\n\t\tsize = Number(result.result);\n\t\tconsumed += result.consumed;\n\t\tremainingBytes = result.encoded;\n\t\tpartsCount = Math.ceil(size / WORD_SIZE);\n\t}\n\tif (size > bytes.length) {\n\t\tthrow new AbiError('there is not enough data to decode', {\n\t\t\ttype: param.type,\n\t\t\tencoded: bytes,\n\t\t\tsize,\n\t\t});\n\t}\n\n\treturn {\n\t\tresult: bytesToHex(remainingBytes.subarray(0, size)),\n\t\tencoded: remainingBytes.subarray(partsCount * WORD_SIZE),\n\t\tconsumed: consumed + partsCount * WORD_SIZE,\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}